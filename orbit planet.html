<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SOLSTARTER</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="three.min.js"></script>
    <script>
      let scene, camera, renderer, torus1, torus2, sphere1, sphere2, sphere3;

      init();

      function deg2rad(degrees) {
        return degrees * (Math.PI / 180);
      }

      function init() {
        scene = new THREE.Scene();
        scene.rotation.set(deg2rad(-60), deg2rad(20), deg2rad(0));
        scene.background = new THREE.Color(0xffffff);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.rotation.set(deg2rad(0), deg2rad(0), deg2rad(0));

        camera.position.set(0, 0, 5);

        scene.add(new THREE.AmbientLight(0x111111));
        const color = 0xffffff;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(10, -20, 15);
        light.target.position.set(0, 0, 0);
        scene.add(light);
        scene.add(light.target);

        //Create Renderer and Append Canvas to body
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        initTorus1();
        initTorus2();
        initSphere1();
        initSphere2();
        initSphere3();

        animate();

        window.addEventListener("resize", onWindowResize);
      }

      function initTorus1() {
        const geometry = new THREE.RingGeometry(3.5, 3.6, 100);
        // const material = new THREE.MeshNormalMaterial({ flatShading: true });
        var material = new THREE.ShaderMaterial({
          uniforms: {
            color1: {
              value: new THREE.Color(0x7ac0bb),
            },
            color2: {
              value: new THREE.Color(0xfffff),
            },
          },
          vertexShader: `
    varying vec2 vUv;

    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
          fragmentShader: `
    uniform vec3 color1;
    uniform vec3 color2;
  
    varying vec2 vUv;
    
    void main() {
      
      gl_FragColor = vec4(mix(color1, color2, vUv.y), 1.0);
    }
  `,
        });
        torus1 = new THREE.Mesh(geometry, material);
        scene.add(torus1);
      }

      function initTorus2() {
        const geometry = new THREE.RingGeometry(3, 3.1, 100);
        var rev = true;
        // const material = new THREE.MeshBasicMaterial({ color: 0x0c6fa6 });
        var cols = [
          {
            stop: 0,
            color: new THREE.Color(0xf7b000),
          },
          {
            stop: 0.25,
            color: new THREE.Color(0xdd0080),
          },
          {
            stop: 0.5,
            color: new THREE.Color(0x622b85),
          },
          {
            stop: 0.75,
            color: new THREE.Color(0x007dae),
          },
          {
            stop: 1,
            color: new THREE.Color(0x77c8db),
          },
        ];

        setGradient(geometry, cols, "x", rev);

        var material = new THREE.MeshBasicMaterial({
          vertexColors: THREE.VertexColors,
        });

        torus2 = new THREE.Mesh(geometry, material);
        scene.add(torus2);
      }

      function setGradient(geometry, colors, axis, reverse) {
        geometry.computeBoundingBox();

        var bbox = geometry.boundingBox;
        var size = new THREE.Vector3().subVectors(bbox.max, bbox.min);

        var vertexIndices = ["a", "b", "c"];
        var face,
          vertex,
          normalized = new THREE.Vector3(),
          normalizedAxis = 0;

        for (var c = 0; c < colors.length - 1; c++) {
          var colorDiff = colors[c + 1].stop - colors[c].stop;

          for (var i = 0; i < geometry.faces.length; i++) {
            face = geometry.faces[i];
            for (var v = 0; v < 3; v++) {
              vertex = geometry.vertices[face[vertexIndices[v]]];
              normalizedAxis = normalized
                .subVectors(vertex, bbox.min)
                .divide(size)[axis];
              if (reverse) {
                normalizedAxis = 1 - normalizedAxis;
              }
              if (
                normalizedAxis >= colors[c].stop &&
                normalizedAxis <= colors[c + 1].stop
              ) {
                var localNormalizedAxis =
                  (normalizedAxis - colors[c].stop) / colorDiff;
                face.vertexColors[v] = colors[c].color
                  .clone()
                  .lerp(colors[c + 1].color, localNormalizedAxis);
              }
            }
          }
        }
      }

      function initSphere1() {
        const geometry = new THREE.SphereGeometry(0.2, 32, 16);
        const material = new THREE.MeshPhongMaterial({
          color: 0x2299c4,
          roughness: 0,
        });
        sphere1 = new THREE.Mesh(geometry, material);
        scene.add(sphere1);
      }

      function initSphere2() {
        const geometry = new THREE.SphereGeometry(0.2, 32, 16);
        const material = new THREE.MeshPhongMaterial({ color: 0xf1e0f2 });
        sphere2 = new THREE.Mesh(geometry, material);
        scene.add(sphere2);
      }

      function initSphere3() {
        const geometry = new THREE.SphereGeometry(0.2, 32, 16);
        const material = new THREE.MeshPhongMaterial({ color: 0x73efd1 });
        sphere3 = new THREE.Mesh(geometry, material);
        scene.add(sphere3);
      }

      //Animate
      function animate() {
        //Call animate function frequently
        requestAnimationFrame(animate);

        const timer = 0.0005 * Date.now();
        sphere1.position.x = Math.cos(timer) * 3.05;
        sphere1.position.y = Math.sin(timer) * 3.05;

        sphere2.position.x = Math.cos(timer + 90) * 3.05;
        sphere2.position.y = Math.sin(timer + 90) * 3.05;

        sphere3.position.x = Math.cos(timer + 180) * 3.55;
        sphere3.position.y = Math.sin(timer + 180) * 3.55;

        //Render Scene and Camera
        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>
  </body>
</html>
